#!/usr/bin/env bash

# initialise bashinate home location
BASHINATE_HOME="~/.bashinate";

# include bashinate path
PATH="~/bin:$BASHINATE_HOME/bin:$PATH";

PATH="~/.cabal/bin:/opt/cabal/1.20/bin:/opt/ghc/7.8.2/bin:/opt/happy/1.19.3/bin:/opt/alex/3.1.3/bin:$PATH"; # haskell
PATH="$PATH:~/packer"; # packer
PATH="$PATH:/opt/LightTable"; #lighttable

# include node in the path
export PATH="`bashinate use node 0.10.29`:$PATH";

# install and use redis if not already available
bashinate use redis 2.8.8

# use rust
bashinate use rust nightly

# init JAVA_HOME
export JAVA_HOME="/usr/lib/jvm/default-java";

# chrome sandbox
export CHROME_DEVEL_SANDBOX=/usr/local/sbin/chrome-devel-sandbox

# openni dev
export OPENNI2_INCLUDE=~/code/misc/OpenNI-Linux-x64-2.2/Include
export OPENNI2_REDIST=~/code/misc/OpenNI-Linux-x64-2.2/Redist

# initialise the bashrc
# alias chrome="rm -rf $HOME/.config/chrome-test && google-chrome --console --no-first-run --user-data-dir=$HOME/.config/chrome-test --use-fake-device-for-media-stream --use-file-for-fake-video-capture=/home/doehlman/testvideo.y4m --enable-logging --v=1 --vmodule=*third_party/libjingle/*=3,*=0"
alias chrome="rm -rf $HOME/.config/chrome-test && google-chrome --console --no-first-run --user-data-dir=$HOME/.config/chrome-test --allow-http-screen-capture --use-fake-device-for-media-stream --enable-logging --v=1 --vmodule=*third_party/libjingle/*=3,*=0"

alias bsize="browserify . --standalone test | uglifyjs | wc -c"

alias dockercleancontainers="docker ps -a --no-trunc| grep 'Exit' | awk '{print \$1}' | xargs -L 1 -r docker rm"
alias dockercleanimages="docker images -a --no-trunc | grep none | awk '{print \$3}' | xargs -L 1 -r docker rmi"
alias dockerclean="dockercleancontainers && dockercleanimages"

# not typically using a gnome environment so better to have this off
unset GNOME_KEYRING_CONTROL

export TIZENSDK_HOME=~/tizen-wearable-sdk
export PATH="$PATH:$TIZENSDK_HOME/tools"

# synaptic client changes
synclient TapButton1=0 TapButton2=0 RTCornerButton=0 RBCornerButton=0 ClickFinger1=0 ClickFinger2=0

#
# Define some colors first: Capitals denote bold
#
red='\e[0;31m'
RED='\e[1;31m'
green='\e[0;32m'
GREEN='\e[1;32m'
yellow='\e[0;33m'
YELLOW='\e[1;33m'
blue='\e[0;34m'
BLUE='\e[1;34m'
magenta='\e[0;35m'
MAGENTA='\e[1;35m'
cyan='\e[0;36m'
CYAN='\e[1;36m'
NC='\e[0m'              # No Color

# Taken from http://www.opinionatedprogrammer.com/2011/01/colorful-bash-prompt-reflecting-git-status/
function _git_prompt() {
  local git_status="`git status -unormal 2>&1`"
  if ! [[ "$git_status" =~ Not\ a\ git\ repo ]]; then
    if [[ "$git_status" =~ nothing\ to\ commit ]]; then
      local ansi=$GREEN
    elif [[ "$git_status" =~ nothing\ added\ to\ commit\ but\ untracked\ files\ present ]]; then
      local ansi=$RED
    else
      local ansi=$YELLOW
    fi
    if [[ "$git_status" =~ On\ branch\ ([^[:space:]]+) ]]; then
      branch=${BASH_REMATCH[1]}
      #test "$branch" != master || branch=' '
    else
      # Detached HEAD.  (branch=HEAD is a faster alternative.)
      branch="(`git describe --all --contains --abbrev=4 HEAD 2> /dev/null ||
      echo HEAD`)"
    fi
    echo -n '[\['"$ansi"'\]'"$branch"'\[\e[0m\]]'
  fi
}

function report_status() {
  RET_CODE=$?
  if [[ $RET_CODE -ne 0 ]] ; then
    echo -ne "[\[$RED\]$RET_CODE\[$NC\]]"
  fi
}

export _PS1="\[$NC\][\u@\h \W]"
export PS2="\[$NC\]> "
export PROMPT_COMMAND='_status=$(report_status);export PS1="$(_git_prompt)${_status}${_PS1}\$ ";unset _status;'

# ensure go is a go
PATH="~/.go/bin:/opt/go/bin:$PATH";
export GOROOT=/opt/go
export GOPATH=~/code/go
mkdir -p $GOPATH

# rvm
[[ -e ~/.rvm/scripts/rvm ]] && . ~/.rvm/scripts/rvm

[[ -e ~/.tools-local ]] && . ~/.tools-local

# include the bash secrets file
[[ -e ~/.bashrc-secrets ]] && . ~/.bashrc-secrets
